 /********************************************************************/
 /*                                                                  */
 /* MODULE NAME = DFH$SNP2                                           */
 /*                                                                  */
 /* DESCRIPTIVE NAME = CICS TS  Password Expiration Management       */
 /*                             sample program for OS/2 Warp         */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*      Licensed Materials - Property of IBM                        */
 /*                                                                  */
 /*      "Restricted Materials of IBM"                               */
 /*                                                                  */
 /*      5655-Y04                                                    */
 /*                                                                  */
 /*      (C) Copyright IBM Corp. 1999"                               */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /* STATUS = 7.2.0                                                   */
 /*                                                                  */
 /* FUNCTION =                                                       */
 /*      This module is an example of how to write a client          */
 /*      application to exploit the Password Expiration Management   */
 /*      server functions of a CICS/ESA or CICS Transaction Server   */
 /*      host system. This version is designed to run under          */
 /*      OS/2 Warp Version 3 or later.                               */
 /*                                                                  */
 /*      For further information on using the Password Expiration    */
 /*      Management interface, see the CICS-RACF Security Guide,     */
 /*      SC33-1701.                                                  */
 /*                                                                  */
 /*                                                                  */
 /* NOTES :                                                          */
 /*  DEPENDENCIES = OS/2 Warp                                        */
 /*  MODULE TYPE = Executable                                        */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /* CHANGE ACTIVITY :                                                */
 /*      $MOD(DFH$SNP2),COMP(SIGNON),PROD(CICS TS ):                 */
 /*                                                                  */
 /*   PN= REASON REL YYMMDD HDXXIII : REMARKS                        */
 /*  $P0= M31338 530 990105 HD2JPEH : Password Expiration Management */
 /*                                                                  */
 /********************************************************************/

 #define LINT_ARGS

 #include <APPC_C.H>
 #include <ACSSVCC.H>
 #include <STDIO.H>
 #include <STDLIB.H>
 #include <STDDEF.H>
 #include <STRING.H>
 #include <DOS.H>
 #include <DOSCALLS.H>

 /* Macro clear_vbc sets the APPC verb control block to zero */
 #define clear_vcb()   memset(&vcb,(int)'\0',sizeof(vcb))

 typedef unsigned int BOOL;
 #define FALSE                 0
 #define TRUE                  1

 /* Type of PEM function, and possible values */
 typedef unsigned int resp_type;
 #define PEM_OK                0
 #define TP_STARTED_FAIL       1
 #define ALLOCATE_FAIL         2
 #define BUFF_ALLOC_FAIL       3
 #define SEND_FAIL             4
 #define RECEIVE_FAIL          5
 #define RECEIVE_DEALLOC_FAIL  6
 #define TP_ENDED_FAIL         7

 /* PEM has two call functions: Sign On and Change Password */
 typedef unsigned int func_type;
 #define SIGN_ON               0
 #define CHANGE                1

 /* APPC return code: Primary and Secondary */
 typedef struct ret_code_str {
         unsigned short p;
         unsigned long  s;
         } APPC_rc;

 /* Length Constants */
 #define PEM_REQ_LEN          45
 #define PEM_RESP_LEN         50
 #define PARTNER_LU_ALIAS_LEN  8
 #define TP_NAME_LEN          64
 #define LU_ALIAS_LEN          8
 #define MODE_NAME_LEN         8
 #define TP_ID_LEN             8

 /* Pointer to alphanumeric shared buffer */
 unsigned char far *anbptr;


 /* Verb Control Block (vcb) - See APPC.H for component declarations */
 union  {
        struct allocate              alloc;
        struct deallocate            dealloc;
        struct receive_and_wait      rcv_wait;
        struct send_data             send;
        struct tp_started            tpstart;
        struct tp_ended              tpend;
        struct convert               cnvt;
        } vcb;

 /* Pointer to the vcb */
 unsigned far *vcbptr;

 /* Function Prototypes */
 #ifdef LINT_ARGS
 void      main(int,char **);
 resp_type pem(func_type,char *,char *,char *,char *,char *,char *,
               char *,char *);
 void      build_request(func_type,char *,char *,char *,char *);
 APPC_rc   TP_STARTED(char *,char *,char *);
 APPC_rc   ALLOCATE(char *,char *,char *,char *,unsigned long *);
 APPC_rc   SEND_REQUEST(char *,unsigned long,char *);
 APPC_rc   RECEIVE_RESPONSE(char *,unsigned long,char *);
 APPC_rc   RECEIVE_DEALLOC(char *,unsigned long);
 APPC_rc   TP_ENDED(char *);
 BOOL      get_shared_buffer(void);
 void      free_shared_buffer(void);
 void      convert_to_EBCDIC(char *, unsigned int);
 void      display_PEM_response(char *);
 #endif

 /*********************************************************************/
 /* MAIN function                                                     */
 /*                                                                   */
 /* This function is a skeleton driver for the PEM function.          */
 /* It takes the arguments specified on the program invocation, and   */
 /* passes them on to PEM.                                            */
 /*                                                                   */
 /* Syntax of program invocation is:                                  */
 /*                                                                   */
 /* PEM partner_LU_alias LU_alias mode_name user_id password          */
 /*                                                  {<new_password>} */
 /*                                                                   */
 /* Input:                                                            */
 /*   ARGC                                                            */
 /*   ARGV                                                            */
 /*                                                                   */
 /*********************************************************************/

 void main(argc,
           argv)

 int       argc;
 char      *argv[];
 {
   resp_type resp;

   func_type function_required;

   unsigned short i, j;




   char      tps_tp_name[TP_NAME_LEN],   /* TP name for TP Started    */
             partner_LU_alias[PARTNER_LU_ALIAS_LEN],
             LU_alias[LU_ALIAS_LEN],
             mode_name[MODE_NAME_LEN],
             user_id[9],                 /* 8 Chars plus null         */
             password[9],
             new_password[9],
             PEM_response[PEM_RESP_LEN]; /* PEM Response Structure    */

   switch (argc) {                       /* If new password specified */
   case  6 : function_required = SIGN_ON; /* No, then Sign On         */
             break;
   case  7 : function_required = CHANGE;  /* Yes, then Change Password*/
             strcpy(new_password, strupr(argv[6]));
             break;
   default : printf("Invalid Syntax\n\n");
             printf("Command Format is:\n\n");
             printf("PEM <partner_LU_alias> <LU_alias> <mode_name> "
                    "<User_Id> <Password> {<New_Password>}\n");
             exit(0);
             break;
   }
   /* Set APPC parameters to blanks */
   memset(tps_tp_name,     (int) ' ', TP_NAME_LEN);
   memset(partner_LU_alias,(int) ' ', PARTNER_LU_ALIAS_LEN);
   memset(LU_alias,        (int) ' ', LU_ALIAS_LEN);
   memset(mode_name,       (int) ' ', MODE_NAME_LEN);

   /* Set APPC Parameters to values specified on the program        */
   /* invocation.                                                   */
   /* Note, as memcpy is being used, the resulting strings          */
   /* will not be null terminated.                                  */
   memcpy(tps_tp_name,      strupr(argv[0]), strlen(argv[0]));
   memcpy(partner_LU_alias, strupr(argv[1]), strlen(argv[1]));
   memcpy(LU_alias,         strupr(argv[2]), strlen(argv[2]));
   memcpy(mode_name,        strupr(argv[3]), strlen(argv[3]));

   /* Set the User-id and password fields */
   strcpy(user_id,  strupr(argv[4]));
   strcpy(password, strupr(argv[5]));


   vcbptr = (unsigned far *)&vcb;      /* Set pointer to vbc       */

   resp = pem(function_required,       /* Issue the PEM request    */
              tps_tp_name,
              partner_LU_alias,
              LU_alias,
              mode_name,
              user_id,
              password,
              new_password,
              PEM_response);




   switch (resp) {             /* Check outcome of request */
   case PEM_OK               : printf("PEM_OK\n\n");
                               display_PEM_response(PEM_response);
                               break;
   case TP_STARTED_FAIL      : printf("TP_STARTED_FAIL\n");
                               break;
   case ALLOCATE_FAIL        : printf("ALLOCATE_FAIL\n");
                               break;
   case BUFF_ALLOC_FAIL      : printf("BUFF_ALLOC_FAIL\n");
                               break;
   case SEND_FAIL            : printf("SEND_FAIL\n");
                               break;
   case RECEIVE_FAIL         : printf("RECEIVE_FAIL\n");
                               break;
   case RECEIVE_DEALLOC_FAIL : printf("RECEIVE_DEALLOC_FAIL\n");
                               break;
   case TP_ENDED_FAIL        : printf("TP_ENDED_FAIL\n");
                               break;
   default                   : printf("Invalid Resp from PEM\n");
                               break;
   }
 }
 /*********************************************************************/

 /*********************************************************************/
 /* APPC Password Expiration Manager (PEM) Requester                  */
 /*                                                                   */
 /* Builds a PEM request structure, sends it to the CICS Server,      */
 /* and receives the response.                                        */
 /* This response structure is passed back to the caller.             */
 /*                                                                   */
 /* Input:                                                            */
 /*   function_required                                               */
 /*   tps_tp_name                                                     */
 /*   partner_LU_alias                                                */
 /*   LU_alias                                                        */
 /*   mode_name                                                       */
 /*   user_id                                                         */
 /*   password                                                        */
 /*   new_password                                                    */
 /*                                                                   */
 /* Output:                                                           */
 /*   PEM_response                                                    */
 /*                                                                   */
 /* Return Value:                                                     */
 /*   rerp_type = {PEM_OK, TP_STARTED_FAIL, ALLOCATE_FAIL,            */
 /*                BUFF_ALLOC_FAIL, SEND_FAIL, RECEIVE_FAIL,          */
 /*                RECEIVE_DEALLOC_FAIL, TP_ENDED_FAIL}               */
 /*                                                                   */
 /*********************************************************************/

 resp_type pem (function_required,
                tps_tp_name,
                partner_LU_alias,
                LU_alias,
                mode_name,
                user_id,
                password,
                new_password,
                PEM_response)

 func_type      function_required;
 char           tps_tp_name[],
                partner_LU_alias[],
                LU_alias[],
                mode_name[],
                user_id[],
                password[],
                new_password[],
                PEM_response[];

 {
   char         tp_name[TP_NAME_LEN],
                tp_id[TP_ID_LEN],
                PEM_request[PEM_REQ_LEN];

   BOOL buffer_allocated;
   APPC_rc ret_code;         /* APPC Primary & Secondary return code */
   unsigned long conv_id;    /* APPC Conversation Id                 */

   /* Set TP Name of CICS PEM server transaction - 0x06F3F0F1 */
   memset(tp_name,     (int) ' ',TP_NAME_LEN);

   tp_name[0] = (char) 0x06;
   tp_name[1] = (char) 0xF3;
   tp_name[2] = (char) 0xF0;
   tp_name[3] = (char) 0xF1;


   /* DOSALLOCSEG for APPC data buffer */
   buffer_allocated = get_shared_buffer();

   if (!buffer_allocated) {
      printf("Buffer allocation failed\n");
      return(BUFF_ALLOC_FAIL);
   }

   /* Build a PEM request structure from the given parameters */
   build_request(function_required,
                 user_id,
                 password,
                 new_password,
                 PEM_request);

   /*Tell APPC a TP has Started */
   ret_code = TP_STARTED(LU_alias,
                         tps_tp_name,
                         tp_id);

   if (ret_code.p != AP_OK) {
      printf("TP_STARTED failed\n");
      printf("APPC Return Code - Primary  : %#010hx \n", ret_code.p);
      printf("                 - Secondary: %#010lx \n", ret_code.s);
      return(TP_STARTED_FAIL);
   }

   /* Allocate APPC session for conversation */
   ret_code = ALLOCATE(tp_id,
                       partner_LU_alias,
                       tp_name,
                       mode_name,
                       &conv_id );

   if (ret_code.p != AP_OK) {
      printf("ALLOCATE failed\n");
      printf("APPC Return Code - Primary  : %#010hx \n", ret_code.p);
      printf("                 - Secondary: %#010lx \n", ret_code.s);
      return(ALLOCATE_FAIL);
   }

   /* Send request to the CICS PEM Server, inviting a response */
   ret_code = SEND_REQUEST(tp_id,
                           conv_id,
                           PEM_request);

   if (ret_code.p != AP_OK) {
      printf("SEND_REQUEST failed\n");
      printf("APPC Return Code - Primary  : %#010hx \n", ret_code.p);
      printf("                 - Secondary: %#010lx \n", ret_code.s);
      return(SEND_FAIL);
   }




   /* Receive response from the CICS PEM Server */
   ret_code = RECEIVE_RESPONSE(tp_id,
                               conv_id,
                               PEM_response);

   if (ret_code.p != AP_OK) {
      printf("APPC RECEIVE failed\n");
      printf("APPC Return Code - Primary  : %#010hx \n", ret_code.p);
      printf("                 - Secondary: %#010lx \n", ret_code.s);
      return(RECEIVE_FAIL);
   }

   /* Receive Deallocation notification from the CICS PEM Server */
   ret_code = RECEIVE_DEALLOC(tp_id,
                              conv_id);

   free_shared_buffer();

   if (ret_code.p != AP_DEALLOC_NORMAL) {
      printf("APPC RECEIVE_DEALLOCATE failed\n");
      printf("APPC Return Code - Primary  : %#010hx \n", ret_code.p);
      printf("                 - Secondary: %#010lx \n", ret_code.s);
      return(RECEIVE_DEALLOC_FAIL);
   }

   /* Tell APPC that transaction program is done */
   ret_code = TP_ENDED(tp_id);

   if (ret_code.p != AP_OK) {
      printf("APPC TP_ENDED failed\n");
      printf("APPC Return Code - Primary  : %#010hx \n", ret_code.p);
      printf("                 - Secondary: %#010lx \n", ret_code.s);
      return(TP_ENDED_FAIL);
   }

   return(PEM_OK);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* build_request                                                     */
 /*                                                                   */
 /* Builds a PEM request structure as defined in the                  */
 /* CICS-RACF Security Guide.                                         */
 /*                                                                   */
 /* Input:                                                            */
 /*   function_required                                               */
 /*   user_id                                                         */
 /*   password                                                        */
 /*   new_password                                                    */
 /*                                                                   */
 /* Output:                                                           */
 /*   PEM_request                                                     */
 /*   User_id, password and new_password will now be in EBCDIC.       */
 /*                                                                   */
 /*********************************************************************/

 void build_request(function_required,
                    user_id,
                    password,
                    new_password,
                    PEM_request)

 func_type          function_required;
 char               user_id[],
                    password[],
                    new_password[],
                    PEM_request[];




 {
 char *sub_field_ptr;     /* Used to build variable length sub fields */
 unsigned int length;     /* Sub field length                         */

   /* Set the GDS Variable ID to 0x1221 */
   PEM_request[2] = (char) 0x12;
   PEM_request[3] = (char) 0x21;

   /* Set the Request field to 0xFF00 for Sign On,        */
   /*                          0xFF01 for Change Password */
   PEM_request[6] = (char) 0xFF;
   if (function_required == SIGN_ON)
      PEM_request[7] = (char) 0x00;
   else
      PEM_request[7] = (char) 0x01;

   /* Set pointer to start of variable length sub fields */
   sub_field_ptr = &PEM_request[8];

   /* set user id sub field - length byte, id 0x01, and EBCDIC value */
   length = strlen(user_id);
   sub_field_ptr[0] = (char) length + 2;
   sub_field_ptr[1] = (char) 0x01;
   convert_to_EBCDIC(user_id, length);
   memcpy(&sub_field_ptr[2], user_id, length);

   /* Set pointer to start of next variable length sub field */
   sub_field_ptr = &sub_field_ptr[2] + length;

   /* set password sub field - length byte, id 0x02, and EBCDIC value*/
   length = strlen(password);
   sub_field_ptr[0] = (char) length + 2;
   sub_field_ptr[1] = (char) 0x02;
   convert_to_EBCDIC(password, length);
   memcpy(&sub_field_ptr[2], password, length);

   /* Set pointer to start of next variable length sub field */
   sub_field_ptr = &sub_field_ptr[2] + length;

   /* If Change Password requested, then include the new password */
   if (function_required == CHANGE) {
     /* set new password sub field                                   */
     /*                     - length byte, id 0x06, and EBCDIC value */
     length = strlen(new_password);
     sub_field_ptr[0] = (char) length + 2;
     sub_field_ptr[1] = (char) 0x06;
     convert_to_EBCDIC(new_password, length);
     memcpy(&sub_field_ptr[2], new_password, length);

     /* Set pointer to start of next variable length sub field */
     sub_field_ptr = &sub_field_ptr[2] + length;
   }

   /* Set GDS Variable LL - high order byte to 0x00,                 */
   /*                       low order byte to the length             */
   /*                           of the built request,                */
   /*                           including the length of this LL.     */
   PEM_request[0] = (char) 0x00;
   PEM_request[1] = (char) (sub_field_ptr - &PEM_request[0]);

   /* Set nested data structure LL - high order byte to 0x00,        */
   /*                                low order byte to the length    */
   /*                                    of the GDS variable,        */
   /*                                    minus the length            */
   /*                                    of the GDS LLID (4 bytes)   */
   PEM_request[4] = (char) 0x00;
   PEM_request[5] = (char) (sub_field_ptr - &PEM_request[0] - 4);
 }
 /*********************************************************************/




 /*********************************************************************/
 /* convert_to_EBCDIC                                                 */
 /*                                                                   */
 /* Converts the given ASCII string to EBCDIC.                        */
 /*                                                                   */
 /* input:                                                            */
 /*   ASCII_string                                                    */
 /*   length                                                          */
 /*                                                                   */
 /* output:                                                           */
 /*   ASCII_string                                                    */
 /*                                                                   */
 /*********************************************************************/

 void convert_to_EBCDIC(ASCII_string, length)

 char ASCII_string[];
 unsigned int length;
 {
   clear_vcb();

   vcb.cnvt.opcode = SV_CONVERT;
   vcb.cnvt.direction = SV_ASCII_TO_EBCDIC;
   vcb.cnvt.char_set = SV_AE;
   vcb.cnvt.len = length;
   vcb.cnvt.source = vcb.cnvt.target
                   = (unsigned char far *)ASCII_string;

   ACSSVC_C ((long) vcbptr);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* get_shared_buffer                                                 */
 /*                                                                   */
 /* APPC requires a data buffer in a shared unnamed segment           */
 /*                                                                   */
 /* return value                                                      */
 /*   BOOL = {TRUE, FALSE}                                            */
 /*                                                                   */
 /*********************************************************************/

 BOOL get_shared_buffer()
 {
   unsigned short dos_rc,
                  selector;


   dos_rc = DOSALLOCSEG(4096, (unsigned far *)&selector, 1);
   if (dos_rc == 0)  {
     FP_OFF(anbptr) = 0;
     FP_SEG(anbptr) = selector;
     return(TRUE);
   }
   else  {
     printf("OS/2 Call error RC = %04d\n",dos_rc);
     anbptr = (unsigned char far *)0;
     return(FALSE);
   }
 }
 /*********************************************************************/


 /*********************************************************************/
 /* free_shared_buffer                                                */
 /*                                                                   */
 /* Free data buffer in the shared unnamed segment                    */
 /*                                                                   */
 /*********************************************************************/

 void
 free_shared_buffer()
 {
   unsigned short dos_rc;

   dos_rc = DOSFREESEG(FP_SEG(anbptr));
   if (dos_rc != 0)
      printf("OS/2 Call error RC = %04d\n",dos_rc);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* TP_STARTED                                                        */
 /*                                                                   */
 /* Notify APPC that we are requesting resources for a transaction    */
 /* program initiated as a result of a local command, rather than     */
 /* an incoming allocation request.                                   */
 /*                                                                   */
 /* input:                                                            */
 /*   LU_alias                                                        */
 /*   tps_tp_name                                                     */
 /*                                                                   */
 /* output:                                                           */
 /*   tp_id                                                           */
 /*   tps_tp_name will now be in EBCDIC                               */
 /*                                                                   */
 /* return value                                                      */
 /*   APPC return code                                                */
 /*                                                                   */
 /*********************************************************************/

 APPC_rc TP_STARTED(LU_alias,
                    tps_tp_name,
                    tp_id)

 char LU_alias[],
      tps_tp_name[],
      tp_id[];
 {
   APPC_rc rc;

   /* The TPS TP name must be in EBCDIC */
   convert_to_EBCDIC(tps_tp_name, TP_NAME_LEN);

   clear_vcb();

   vcb.tpstart.opcode = AP_TP_STARTED;

   memcpy (vcb.tpstart.lu_alias, LU_alias, LU_ALIAS_LEN);
   memcpy (vcb.tpstart.tp_name, tps_tp_name, TP_NAME_LEN);

   APPC_C ((long) vcbptr);

   rc.p = vcb.tpstart.primary_rc;
   rc.s = vcb.tpstart.secondary_rc;

   /* If call was sucessful, return the assigned TP id */
   if (rc.p == AP_OK)
     memcpy (tp_id, vcb.tpstart.tp_id, TP_ID_LEN);

   return(rc);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* ALLOCATE                                                          */
 /*                                                                   */
 /* Allocate a session between the local and partner LUs.             */
 /* This conversation will be of type - basic, synclevel - none,      */
 /* security - none, and will return control when a session is        */
 /* allocated.                                                        */
 /*                                                                   */
 /* input:                                                            */
 /*   tp_id                                                           */
 /*   partner_LU_alias                                                */
 /*   tp_name                                                         */
 /*   mode_name                                                       */
 /*                                                                   */
 /* output:                                                           */
 /*   conv_id                                                         */
 /*   mode_name will now be in EBCDIC                                 */
 /*                                                                   */
 /* return value                                                      */
 /*   APPC return code                                                */
 /*                                                                   */
 /*********************************************************************/

 APPC_rc
 ALLOCATE (tp_id,
           partner_LU_alias,
           tp_name,
           mode_name,
           conv_id)

 char      tp_id[],
           partner_LU_alias[],
           tp_name[],
           mode_name[];

 unsigned long *conv_id;
 {
   APPC_rc rc;



   /* The mode name must be in EBCDIC */
   convert_to_EBCDIC(mode_name, MODE_NAME_LEN);

   clear_vcb();

   vcb.alloc.opcode     = AP_B_ALLOCATE;
   vcb.alloc.opext      = AP_BASIC_CONVERSATION;
   vcb.alloc.sync_level = AP_NONE;
   vcb.alloc.security   = AP_NONE;
   vcb.alloc.rtn_ctl    = AP_WHEN_SESSION_ALLOCATED;

   memcpy (vcb.alloc.tp_id, tp_id, TP_ID_LEN);
   memcpy (vcb.alloc.plu_alias, partner_LU_alias, PARTNER_LU_ALIAS_LEN);
   memcpy (vcb.alloc.tp_name, tp_name, TP_NAME_LEN);
   memcpy (vcb.alloc.mode_name, mode_name, MODE_NAME_LEN);

   APPC_C ((long) vcbptr);

   rc.p = vcb.alloc.primary_rc;
   rc.s = vcb.alloc.secondary_rc;

   /* if th call was successful, set the conv_id assigned */
   if (rc.p == AP_OK)
     *conv_id = vcb.alloc.conv_id;

   return(rc);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* SEND_REQUEST                                                      */
 /*                                                                   */
 /* Send the PEM request to the CICS PEM Server.                      */
 /* The send will flush the data, and will prepare to receive.        */
 /*                                                                   */
 /* input:                                                            */
 /*   tp_id                                                           */
 /*   conv_id                                                         */
 /*   PEM_request                                                     */
 /*                                                                   */
 /* return value                                                      */
 /*   APPC return code                                                */
 /*                                                                   */
 /*********************************************************************/

 APPC_rc
 SEND_REQUEST(tp_id,
              conv_id,
              PEM_request)

 unsigned long conv_id;
 char          tp_id[],
               PEM_request[];
 {
   register unsigned msg_len;
   unsigned short send_length;
   APPC_rc rc;

   /* Set send length to low order byte of GDS variable LL */
   send_length = (int) PEM_request[1];
   msg_len = send_length;




   /* Copy PEM request to shared buffer */
   for(;msg_len;)  {
     msg_len--;
     anbptr[msg_len] = PEM_request[msg_len];
   }

   clear_vcb();

   vcb.send.opcode  = AP_B_SEND_DATA;
   vcb.send.opext   = AP_BASIC_CONVERSATION;
   vcb.send.type    = AP_SEND_DATA_P_TO_R_FLUSH;   /* invite response */
   vcb.send.conv_id = conv_id;
   vcb.send.dlen    = send_length;
   vcb.send.dptr    = anbptr;

   memcpy (vcb.send.tp_id, tp_id, TP_ID_LEN);

   APPC_C ((long) vcbptr);

   rc.p = vcb.send.primary_rc;
   rc.s = vcb.send.secondary_rc;

   return(rc);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* RECEIVE_RESPONSE                                                  */
 /*                                                                   */
 /* Receive the PEM response structure,                               */
 /* (as defined in the CICS-RACF Security Guide)                      */
 /* from the CICS PEM Server.                                         */
 /*                                                                   */
 /* input:                                                            */
 /*   tp_id                                                           */
 /*   conv_id                                                         */
 /*                                                                   */
 /* output:                                                           */
 /*   PEM_response                                                    */
 /*                                                                   */
 /* return value                                                      */
 /*   APPC return code                                                */
 /*                                                                   */
 /*********************************************************************/

 APPC_rc
 RECEIVE_RESPONSE(tp_id,
                  conv_id,
                  PEM_response)

 unsigned long    conv_id;
 char             tp_id[],
                  PEM_response[];
 {
   unsigned short received_length,
                  max_length;
   APPC_rc rc;

   max_length = PEM_RESP_LEN;

   clear_vcb();

   vcb.rcv_wait.opcode     = AP_B_RECEIVE_AND_WAIT;
   vcb.rcv_wait.opext      = AP_BASIC_CONVERSATION;
   vcb.rcv_wait.rtn_status = AP_NO;
   vcb.rcv_wait.conv_id    = conv_id;
   vcb.rcv_wait.max_len    = max_length;
   vcb.rcv_wait.dptr       = anbptr;


   memcpy (vcb.rcv_wait.tp_id, tp_id, TP_ID_LEN);

   APPC_C ((long) vcbptr);

   rc.p = vcb.rcv_wait.primary_rc;
   rc.s = vcb.rcv_wait.secondary_rc;

   /* If response received ok, then copy data from shared buffer */
   if (rc.p == AP_OK) {
     received_length = vcb.rcv_wait.dlen;

     for(;received_length;) {
       received_length--;
       PEM_response[received_length] = anbptr[received_length];
     }
   }

   return(rc);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* RECEIVE_DEALLOC                                                   */
 /*                                                                   */
 /* Receive deallocation notification (AP_DEALLOC_NORMAL return code) */
 /* from the CICS PEM Server.  If this is not received, then          */
 /* termination of the conversation is forced by issuing a deallocate */
 /* abend.                                                            */
 /*                                                                   */
 /* input:                                                            */
 /*   tp_id                                                           */
 /*   conv_id                                                         */
 /*                                                                   */
 /* return value                                                      */
 /*   APPC return code                                                */
 /*                                                                   */
 /*********************************************************************/

 APPC_rc
 RECEIVE_DEALLOC(tp_id,
                 conv_id)

 unsigned long   conv_id;
 char            tp_id[];
 {
   APPC_rc rc;

   clear_vcb();

   vcb.rcv_wait.opcode     = AP_B_RECEIVE_AND_WAIT;
   vcb.rcv_wait.opext      = AP_BASIC_CONVERSATION;
   vcb.rcv_wait.rtn_status = AP_NO;
   vcb.rcv_wait.conv_id    = conv_id;
   vcb.rcv_wait.max_len    = 50;     /* Arbitrary length */
   vcb.rcv_wait.dptr       = anbptr;

   memcpy (vcb.rcv_wait.tp_id, tp_id, TP_ID_LEN);

   APPC_C ((long) vcbptr);

   rc.p = vcb.rcv_wait.primary_rc;
   rc.s = vcb.rcv_wait.secondary_rc;


   /* If conversation has not been terminated by the CICS PEM        */
   /* Server, then we issue a deallocate abend to force termination. */
   if (!(rc.p == AP_DEALLOC_NORMAL |
         rc.p == AP_DEALLOC_ABEND_PROG |
         rc.p == AP_DEALLOC_ABEND_SVC |
         rc.p == AP_DEALLOC_ABEND_TIMER |
         rc.p == AP_CONV_FAILURE_NO_RETRY |
         rc.p == AP_CONV_FAILURE_RETRY)) {

     clear_vcb();

     vcb.dealloc.opcode       = AP_B_DEALLOCATE;
     vcb.dealloc.opext        = AP_BASIC_CONVERSATION;
     vcb.dealloc.dealloc_type = AP_ABEND;
     vcb.dealloc.conv_id      = conv_id;

     memcpy (vcb.dealloc.tp_id, tp_id, TP_ID_LEN);

     APPC_C ((long) vcbptr);
   }

   return(rc);
 }
 /*********************************************************************/


 /*********************************************************************/
 /* DO_TP_ENDED                                                       */
 /*                                                                   */
 /* Notify APPC of the end of this transaction program.               */
 /*                                                                   */
 /* input:                                                            */
 /*   tp_id                                                           */
 /*                                                                   */
 /* return value                                                      */
 /*   APPC return code                                                */
 /*                                                                   */
 /*********************************************************************/

 APPC_rc
 TP_ENDED(tp_id)

 char     tp_id[];
 {
   APPC_rc rc;

   clear_vcb();

   vcb.tpend.opcode = AP_TP_ENDED;

   memcpy (vcb.tpend.tp_id, tp_id, TP_ID_LEN);

   APPC_C ( (long) vcbptr );

   rc.p = vcb.tpend.primary_rc;
   rc.s = vcb.tpend.secondary_rc;

   return(rc);
 }
 /*********************************************************************/

 /*********************************************************************/
 /* display_PEM_response                                              */
 /*                                                                   */
 /* Displays the date returned in the PEM response structure.         */
 /*                                                                   */
 /* input:                                                            */
 /*   PEM_response                                                    */
 /*                                                                   */
 /*********************************************************************/



 void display_PEM_response(PEM_response)

 char PEM_response[];
 {
   unsigned int index,
                length,
                sub_field_len,
                i;

   length = (unsigned int) PEM_response[1];

   /* Display GDS LLID */
   printf("GDS LLID\n");

   for(index = 0; index <= 3; index++)
     printf("%02hx ", (unsigned char) PEM_response[index]);
     printf("\n\n");

   /* Display Sign-On Reply LLID */
   printf("Sign-On Reply LLID\n");

   for(; index <= 7; index++)
     printf("%02hx ", (unsigned char) PEM_response[index]);
   printf("\n\n");

   /* Display Sign_on Completion Status Subfield */
   printf("Sign-On Completion Status Subfield\n");

   for(; index <= 10; index++)
     printf("%02hx ", (unsigned char) PEM_response[index]);
   printf("\n\n");

   while (index < length) {
     sub_field_len = (unsigned int) PEM_response[index];

     /* Switch on Sub Field ID */
     switch((unsigned int) PEM_response[index + 1]) {
     case 0x01 : printf("Sign-On Request Formating Error "
                        "Subfield\n");

                 for(i = 0; i < sub_field_len; i++)
                   printf("%02hx ",
                          (unsigned char)PEM_response[index+i]);
                 printf("\n\n");
                 index = index + i;
                 break;
     case 0x02 : printf("Date & Time of Current Successful "
                        "Sign-On Subfield\n");

                 for(i = 0; i < sub_field_len; i++)
                   printf("%02hx ",
                          (unsigned char)PEM_response[index+i]);
                 printf("\n\n");
                 index = index + i;
                 break;
     case 0x03 : printf("Date & Time of Last Successful "
                        "Sign-On Subfield\n");

                 for(i = 0; i < sub_field_len; i++)
                   printf("%02hx ",
                          (unsigned char)PEM_response[index+i]);
                 printf("\n\n");
                 index = index + i;
                 break;
     case 0x04 : printf("Date & Time Password will "
                        "Expire Subfield\n");

                 for(i = 0; i < sub_field_len; i++)
                   printf("%02hx ",
                          (unsigned char)PEM_response[index+i]);
                 printf("\n\n");
                 index = index + i;
                 break;
     case 0x05 : printf("Revoke Count Subfield\n");



                 for(i = 0; i < sub_field_len; i++)
                   printf("%02hx ",
                          (unsigned char)PEM_response[index+i]);
                 printf("\n\n");
                 index = index + i;
                 break;
     default :   printf("Invalid Subfield ID\n");
                 index = PEM_RESP_LEN;
     }
     }
     }
